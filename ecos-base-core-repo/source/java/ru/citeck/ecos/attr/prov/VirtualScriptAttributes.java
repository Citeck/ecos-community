package ru.citeck.ecos.attr.prov;

import org.alfresco.repo.jscript.ScriptNode;
import org.alfresco.service.ServiceRegistry;
import org.alfresco.service.cmr.dictionary.DataTypeDefinition;
import org.alfresco.service.cmr.repository.MLText;
import org.alfresco.service.cmr.repository.NodeRef;
import org.alfresco.service.cmr.repository.ScriptService;
import org.alfresco.service.namespace.QName;
import org.alfresco.service.namespace.QNamePattern;
import org.alfresco.service.namespace.RegexQNamePattern;
import org.apache.log4j.Logger;
import org.springframework.extensions.surf.util.I18NUtil;
import ru.citeck.ecos.attr.AbstractAttributeProvider;
import ru.citeck.ecos.model.AttributeModel;
import ru.citeck.ecos.node.NodeInfo;
import ru.citeck.ecos.utils.DictionaryUtils;

import java.util.*;

/**
 * Script attributes provider.
 *
 * Allow to work with attributes generated by script
 *
 * @author Pavel Simonov
 */
public class VirtualScriptAttributes extends AbstractAttributeProvider {

    private final Logger logger = Logger.getLogger(VirtualScriptAttributes.class);

    private Map<QName, Set<QName>> attributesByClass = new HashMap<>();
    private Map<QName, AttributeDefinition> attributes = new HashMap<>();
    private ServiceRegistry serviceRegistry;
    private ScriptService scriptService;

    @Override
    public QNamePattern getAttributeNamePattern() {
        return RegexQNamePattern.MATCH_ALL;
    }

    @Override
    public boolean provides(QName attributeName) {
        return attributes.containsKey(attributeName);
    }

    @Override
    public Set<QName> getPersistedAttributeNames(NodeRef nodeRef, boolean justCreated) {
        return getDefinedAttributeNames(nodeService.getType(nodeRef), true);
    }

    @Override
    public Set<QName> getDefaultAttributeNames(NodeRef nodeRef) {
        return getDefinedAttributeNames(nodeService.getType(nodeRef), true);
    }

    @Override
    public Set<QName> getDefinedAttributeNames(NodeRef nodeRef) {
        return getDefinedAttributeNames(nodeService.getType(nodeRef), true);
    }

    @Override
    public Set<QName> getDefinedAttributeNames(QName className, boolean inherit) {
        if (inherit) {
            Collection<QName> typeNames = DictionaryUtils.getAllTypeNames(className, dictionaryService);
            Set<QName> result = new HashSet<>();
            for(QName name : typeNames) {
                Set<QName> attributes = attributesByClass.get(name);
                if (attributes != null) result.addAll(attributes);
            }
            return result;
        } else {
            Set<QName> attributes = attributesByClass.get(className);
            return attributes == null ? Collections.EMPTY_SET : attributes;
        }
    }

    @Override
    public Object getAttribute(NodeRef nodeRef, QName attributeName) {

        Map<String, Object> model = new HashMap<>();
        model.put("node", new ScriptNode(nodeRef, serviceRegistry));

        AttributeDefinition attribute = attributes.get(attributeName);
        Object result = null;
        try {
            result = scriptService.executeScriptString(attribute.script, model);
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
        }
        return result;
    }

    @Override
    public void setAttribute(NodeInfo nodeInfo, QName attributeName, Object value) {
        //nothing
    }

    @Override
    public QName getAttributeType(QName attributeName) {
        return AttributeModel.TYPE_VIRTUAL;
    }

    @Override
    public QName getAttributeSubtype(QName attributeName) {
        return DataTypeDefinition.TEXT;
    }

    @Override
    public Class<?> getAttributeValueType(QName attributeName) {
        return String.class;
    }

    public AttributeDefinition getAttributeDefinition(QName attributeName) {
        return attributes.get(attributeName);
    }

    public void registerAttribute(QName className, QName name, MLText title, String template) {
        if (!addClassAttribute(className, name)) {
            throw new IllegalStateException(String.format("Template attribute %s is already " +
                                                          "registered for class %s!", name, className));
        }
        AttributeDefinition attribute = new AttributeDefinition(name, className, title, template);
        attributes.put(name, attribute);
    }

    private boolean addClassAttribute(QName className, QName attributeName) {
        Set<QName> result = attributesByClass.get(className);
        if (result == null) {
            result = new HashSet<>();
        } else if (result.contains(attributeName)) {
            return false;
        }
        result.add(attributeName);
        attributesByClass.put(className, result);
        return true;
    }

    public void setServiceRegistry(ServiceRegistry serviceRegistry) {
        this.serviceRegistry = serviceRegistry;
        this.scriptService = serviceRegistry.getScriptService();
    }

    public static class AttributeDefinition {
        public final QName name;
        public final QName className;
        public final String script;
        private final MLText title;

        public AttributeDefinition(QName name, QName className, MLText title, String script) {
            this.name = name;
            this.className = className;
            this.script = script;
            this.title = title;
        }

        public String getTitle() {
            return title.getClosestValue(I18NUtil.getLocale());
        }
    }
}
